# 이승엽 202030121

## 4월 5일 객체

1. 객체
  * 실세계 객체의 특징  
    -객체마다 고유한 특성과 행동을 가짐  
    -다른 객체들과 정보를 주고 받는 등, 상호작용하면서 살아감  
  * 컴퓨터 프로그램에서 객체 사례  
    -테트리스 게임의 각 블록들  
    -한글 프로그램의 메뉴나 버튼들  
2. 객체 지향 특성 : 캡슐화
  * 캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것  
    -객체의 가장 본질적인 특징  
    (외부의 접근으로부터 객체)  
  * 자바의 캡슐화  
    -클래스 : 객체 모양을 선언한 틀(캡슐화하는 틀)  
    -객체 : 생성된 실체  
3. 객체 지향 특성 : 상속  
  * 상속  
    -상위 개체의 속성이 하위 개체에 물려짐  
    -하위 개체가 상위 개체의 속성을 모두 가지는 관계  
4. 자바 상속  
  * 상위 클래스의 멤버를 하위 클래스가 물려받음    
    -상위 클래스 : 수퍼 클래스  
    -하위 클래스 : 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능  
5. 객체 지향 특성 : 다향성
  * 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것  
  * 다형성 사례  
    -메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드  
    -메소드 오버라이딩 : 수퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현  
6. 객체 지향 언어의 목적
  * 1 소프트웨어의 생산성 향상  
    * 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축         
      -소프트웨어를 빠른 속도로 생산할 필요성 증대  
    * 객체 지향 언어  
      -상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장  
      -소프트웨어를 다시 만드는 부담 대폭 줄임  
      -소프트웨어 생산성 향상  

  *  2 실세계에 대한 쉬운 모델링  
    * 초기 프로그래밍     
      -수학 게산/통게 처리를 하는 등 처리 과정, 계산 절차 중요
    * 현대 프로그래밍  
      -컴퓨터가 산업 전반에 활용  
      -실세계에서 발생하는 일을 프로그래밍  
      -실세계에서는 절차나 과정보다 객체들의 상호작용으로 묘사하는 것이 용이  
    * 객체 지향 언어  
      -실세계의 일을 보다 쉽게 프로그래밍하기 위한 객체 중심적 언어 
7. 절차 지향 프로그래밍과 객체 지향 프로그래밍  
  * 절차 지향 프로그래밍  
    -작업 순서를 표현하는 컴퓨터 명령 집합  
    -함수들의 집합으로 프로그램 작성  
  * 객체 지향 프로그래밍  
    -컴퓨터가 수행하는 작업을 객체들간의 상호작용으로 표현  
    -클래스 혹은 객체들의 집합으로 프로그램 작성      
8. 클래스와 객체
  * 클래스  
    -객체의 속성과 행위 선언  
    -객체의 설계도 혹은 틀  
  * 객체  
    -클래스의 틀로 찍어낸 실체  
    (프로그램 실행 중에 생성되는 실체, 메모리 공간을 갖는 구체적인 실체)  
9. 자바 클래스 구성
  * 클래스  
    -class 키워드로 구성 요소
    -멤버 : 클래스 구성 요소  
    (필드(멤버 변수) 와 메소드(멤버 함수))  
    -클래스에 대한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락  
    -멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용  
10. 생성자 개념과 목적
  * 생성자  
    -객체가 생성될 때 초기화 목적으로 실행되는 메소드  
    -객체가 생성되는 순간에 자동 호출  
11. 생성자의 특징
  * 생성자 이름은 클래스 이름과 동일  
  * 생성자는 여러 개 작성 가능(생성자 중복)  
    ```
    public class Circle {  
      public Circle() {...} // 매개 변수 없는 생성자
      public Circle(int r, String n) {...} // 2개의 매개 변수를 가진 생성자
    }
    ```
  * 생성자는 객체 생성시 한 번만 호출  
    -자바에서 객체 생성은 반드시 new 연산자로 함  
    ```
    Circle pizza = new Circle(10, "자바피자"); // 생성자 Circle(int r, String n) 호출
    Circle donut = new Circle(); // 생성자 Circle() 호출
    ```
  * 생성자의 목적은 객체 생성 시 초기화  
  * 생성자는 리턴 타입을 지정할 수 없음      
12. 기본 생성자
  * 매개 변수 없고, 아무 작업 없이 단순 리턴하는 생성자  
  ```
  class Circle {
    public Circle() {} // 기본 생성자
  }
  ```  
  * 디폴트 생성자라고도 불림  
13. 기본 생성자가 자동 생성되는 경우
  * 클래스에 생성자가 하나도 선언되어 있지 않을 때  
    -컴파일러에 의해 기본 생성자 자동 생성  
14. 기본 생성자가 자동 생성되지 않는 경우
  * 클래스에 생성자가 선언되어 있는 경우  
    -컴파일러는 기본 생성자를 자동 생성해 주지 않는다.  
15. this 레퍼런스          
  * 객체 자신에 대한 레퍼런스 
    -컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨 
    -this.멤버 형태로 멤버를 접근할 때 사용 
16. this()로 다른 생성자 호출
  * 같은 클래스의 다른 생성자 호출  
  * 생성자 내에서만 사용 가능 
  * 생성자 코드의 제일 처음에 있어야 함 
    -this() 사용 실패 사례  
    ```
    public Book {
      System.out.println("생성자 호출됨");
      this("", "", 0); // 생성자의 첫 번째 문장이 아니기 때문에 컴파일 오류
    }
    ```    
17. 객체 배열
  * 자바의 객체 배열  
    -객체에 대한 레퍼런스 배열임  
  * 자바의 객체 배열 만들기 3단계 
    -1 배열 레퍼런스 변수 선언  
    -2 래퍼런스 배열 생성 
    -3 배열의 각 원소 객체 생성 
18. 메소드
  * 메소드는 c / c++ 의 함수와 동일 
  * 자바의 모든 메소드는 반드시 클래스 안에 있어야 함(캡슐화 원칙)  
19. 메소드 형식
  * 접근 지정자 
    -다른 클래스에서 메소드를 접근할 수 있는지 여부 선언  
    -public, private, protected, 디폴트(접근 지정자 생략)   
  * 리턴 타입  
    -메소드가 리턴하는 값의 데이터 타입  
20. 인자 전달 - 기본 타입의 값이 전달되는 경우
  * 매개 변수가 byte. int. double 등 기본 타입으로 선언되었을 때  
    -호출자가 건네는 값이 매개 변수에 복사되어 전달(실인자 값은 변경되지 않음)  
21. 인자 전달 - 객체가 전달되는 경우
  * 객체의 레퍼런스만 전달  
    -매개 변수가 실인자 객체 공유  
22. 인자 전달 - 배열이 전달되는 경우
  * 배열 레퍼런스만 매개 변수에 전달  
    -배열 통째로 전달되지 않음  
  * 객체가 전달되는 경우와 동일  
    -매개 변수가 실인자의 배열 공유      
23. 메소드 오버로딩    
  * 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성  
    -메소드 이름이 동일하여야 함  
    -매개 변수의 개수가 서로 다르거나, 타입이 서로 달라야 함  
    -리턴 타입은 오버로딩과 관련 없음  
24. 객체 소멸
  * new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위  
  * 소멸된 객체 공간은 가용 메모리에 포함  
25. 자바에서 사용자 임의로 객체 소멸안됨
  * 자바는 객체 소멸 연산자 없음  
    -객체 생성 연산자 : new  
  * 객체 소멸은 자바 가상 기계의 고유한 역할  
  * 자바 개발자에게는 매우 다행스러운 기능  
    -C / C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함  
    -C / C++의 프로그램 작성을 어렵게 만드는 요인  
    -자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방
26. 가비지
  * 가리키는 레퍼런스가 하나도 없는 객체  
    -더 이상 접근할 수 없어  사용할 수 없게 된 메모리  
27. 가비지 컬렉션
  * 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
  * 자바 가상 기계가 가비지 자동 회수  
    -가용 메모리 공간이 일정 이하로 부족해질 때  
    -가비지를 수거하여 가용 메모리 공간으로 확보  
  * 가비지 컬렉터에 의해 자동 수행  
28. 강제 가비지 컬렉션 강제 수행
  * System 또는 Runtime 객체의 gc() 메소드 호출  
  ```System.gc(); // 가비지 컬렉션 작동 요청```  
    -이 코드는 자바 가상 기계에 강력한 가비지 컬렉션 요청  
    -그러나 자바 가상 기계가 가비지 컬렉션 시점을 전적으로 판단      

## 4월 5일

1. 2차원 배열
  * 2차원 배열의 선언과 생성   
    -``int intArray[][]; 또는 int[][] intArray;``  
    -`intArray = new int[2][5];` // 2행 5열의 2차원 배열 생성
2. 메소드의 배열 리턴
  * 배열 리턴  
    -배열의 레퍼런스만 리턴(배열 전체가 리턴되는 것이 아님)  
  * 메소드의 리턴 타입  
    -리턴하는 배열 타입과 리턴 받는 배열 타입 일치  
    -리턴 타입에 크기를 지정하지 않음  
3. 자바의 예외 처리
  * 예외  
    -실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생  
    (자바에서는 실행 중 발생하는 에러를 에외로 처리)  
  * 실행 중 예외가 발생하면  
    -자바 플랫폼은 응용프로그램이 예외를 처리하도록 호출  
    (응용프로그램이 예외를 처리하지 않으면 강제종료)  
  * 예외 발생 경우  
    -정수를 0으로 나누는 경우  
    -배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우  
    -정수를 읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우  
4. 자바의 예외 처리 try-catch-finally 문
  * 예외 처리  
    -발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것  
    -finally 블록은 생략 가능  


## 3월 29일

1. 리터럴
* 리터럴    
-프로그램에서 직접 표현한 값  
-정수, 실수, 문자, 논리 문자열 리터럴 있음
* 정수 리터럴은 int 형으로 컴파일  
* 단일 인용부호`(' ')`로 문자 표현
* 특수문자 리터럴은 백슬래시`(\)`로 시작

2. 상수
* 상수 선언  
 -final 키워드 사용  
 -선언 시 조깃값 지정  
 -실행 중 값 변경 불가 

 3. var 키워드  
 -타입을 생략하고 변수 선언 가능  
 -컴파일러가 추론하여 변수 타입 결정  
 -변수 선언 시 초기값이 주어지지 않으면 컴파일 오류  
 -var는 지역 변수 선언에만 한정 

 4. 타입 변환  
 * 타입 변환  
 -한 타입의 값을 다른 타입의 값으로 변환    
 * 자동 타입 변환
 <!-- -너무 빨라서 못적음 -->
 * 강제 타입 변환  
 -개발자의 의도적 타입 변환  
 -() 안에 개발자가 명시적으로 타입 변환 지정  
 -강제 변환은 값 손실 우려  

 5. Scanner
 * Scanner 클래스  
 -읽은 바이트를 문자, 정수, 실수, 볼린, 문자열 등 다양한 타입으로 변환하여 리턴  
 * 객체 생성  
 -키보드에 연결된 system.ini에게 키를 읽게하고  

 6. 식과 연산자
 * 연산  
 -주어진 식을 계산하여 결과를 얻어내는 과정  

 7. 조건문
 * 단순 if문  
 -if의 괄호 안에 조건식(논리형 변수나 논리 연산)  
 * if-else
 -조건식이 true면 실행 false면 실행 안함
 * 다중 if문  
 -조건문이 너무 많은 경우, switch 문 사용 권장  
 * switch문은 식과 case문의 값과 비교  
 -case의 비교 값과 일치하면 해당 case의 실행문장 수행
 * switch문 내의 break문  
 -break문을 만나면 switch문 벗어남  
 * case문의 값  
 -문자, 정수, 문자열 리터럴만 허용  
 -실수 리터럴은 허용되지 않음 

## 3월 22일
1. 자바 프로젝트를 따로 생성하지 않고 
자바파일을 따로 만들고 컴파일 하는법
* 워크스테이션에 임의의 폴더를 만든 후 제목.java 파일을 생성 (vscode에서 폴더열기)  
그 후 해당 폴더의 파일탐색기에서 좌측 상단에 파일-파워셀 실행  
``javac 제목.java`` 입력하면 컴파일된 파일이 생성  
`java 제목` 입력 시 실행

## 3월 15일
깃허브 사용법

## 3월 8일

# Markdown 문법
## 폰트관련 태그
## h2
### h3  
일반 글씨는 그냥 작성   <br><br>
개행(Newline)을 하려면  
스페이스 2개 입력  
*이텔릭체*  
**볼드체**  
***이텔릭+볼드***

## 리스트(List)
1. 첫 번째
2. 두 번째
3. 세 번쨰

* 첫 번째
    * 두 번째
        - 세 번째

## 코드블럭
```java
public class Main {
  public static void main(String[] args) {
    System.out.println("Hello World");
  }
}
```       

---

## 링크
[구글 링크](https://www.google.co.kr/)  
[리스트](#markdown-문법)  
![상대경로](./1.jpg)
![절대경로](https://newsimg-hams.hankookilbo.com/2022/05/19/624e4207-9ee4-46db-ab65-76cc882eb4c2.jpg)